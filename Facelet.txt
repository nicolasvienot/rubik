extern crate rand;

use rand::Rng;

use super::action::*;

pub enum Facelet {
    U1, U2, U3, U4, U5, U6, U7, U8, U9,
    R1, R2, R3, R4, R5, R6, R7, R8, R9,
    F1, F2, F3, F4, F5, F6, F7, F8, F9,
    D1, D2, D3, D4, D5, D6, D7, D8, D9,
    L1, L2, L3, L4, L5, L6, L7, L8, L9,
    B1, B2, B3, B4, B5, B6, B7, B8, B9
}

#[derive(Debug, Clone)]
pub enum Face {
    U, R, F, D, L, B
}

pub struct RubikState([Face; 54]);

impl RubikState {
    pub fn new_solved() -> RubikState {
        return RubikState([
            Face::U, Face::U, Face::U, Face::U, Face::U, Face::U, Face::U, Face::U, Face::U,
            Face::R, Face::R, Face::R, Face::R, Face::R, Face::R, Face::R, Face::R, Face::R,
            Face::F, Face::F, Face::F, Face::F, Face::F, Face::F, Face::F, Face::F, Face::F,
            Face::D, Face::D, Face::D, Face::D, Face::D, Face::D, Face::D, Face::D, Face::D,
            Face::L, Face::L, Face::L, Face::L, Face::L, Face::L, Face::L, Face::L, Face::L,
            Face::B, Face::B, Face::B, Face::B, Face::B, Face::B, Face::B, Face::B, Face::B
        ]);
    }

    pub fn new_random(iteration: usize) -> RubikState {
        let mut state: RubikState = RubikState::new_solved();
        let sequence: Vec<Action> = (0..iteration).map(|_| {
            let faces: Vec<Face> = vec![Face::U, Face::F, Face::L, Face::D, Face::R, Face::B];
            let rotations: Vec<Rotation> = vec![Rotation::L, Rotation::R, Rotation::D];
            let current_face: Face = faces[rand::thread_rng().gen_range(0, faces.len())].clone();
            let current_rot: Rotation = rotations[rand::thread_rng().gen_range(0, rotations.len())].clone();
            return Action::new(current_face, current_rot);
        }).collect::<Vec<Action>>();
        state.shuffle(sequence);
        return state;
    }

    pub fn shuffle(&mut self, sequence: Vec<Action>) {
        for action in sequence.iter() {
            action.apply_to(self);
        }
    }
}